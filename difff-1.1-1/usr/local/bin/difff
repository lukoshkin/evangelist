#!/bin/bash

if [[ $EDITOR = nvim ]]; then
  vimdiff () { nvim -d "$@"; }
fi

## On which exit status to print help message
PRINT_ES=21

help_msg () {
  printf 'Usage from anywhere:\n'
  printf '    diff [<options>] -D1 <project> -D2 <counter>\n'
  printf 'From a <project> directory:\n'
  printf '    difff [<options>] <prefix>\n'
  printf '<prefix> is the path to a <counter> directory\n\n'

  printf 'Allowed <options>:\n'
  printf '%-20s %s\n' '-s|--staged' 'use --staged flag in `git diff`.'
  printf '%-20s %s\n' '-n|--dry-run' 'show how it would be w/o doing anything.'
  printf '%-20s %s\n' '-a|--add-new' 'add-new files from the counterpart directory.'

  printf '%-20s %s\n' '-m|--mode=<mode>' '<mode> can be git or folder.'
  printf '%-20s %s\n' '-d|--folder=<dir>' 'parent folder of the target directory limiting #files to be compared.'
  printf '%-20s %s\n' '-t|--trim-cnt=<N>' 'trim <N> leading dirs from the target directory path.'
}


function difff () {
  local long_opts='trim-cnt:,folder:,mode:,staged,dry-run,add-new,D1:,D2:,help'
  local short_opts='t:,d:,m:,s,n,a,h'
  local params

  params=$(getopt -o $short_opts -l $long_opts --name "$0" -- "$@") \
    || { echo Aborting..; return $PRINT_ES; }
  eval set -- "$params"

  local folder prefix
  local staged dry_run add_new mode trim_cnt
  while [[ $1 != -- ]]; do
    case $1 in
      -h|--help)        help_msg; return ;;
      -s|--staged)      staged=--staged; shift 1 ;;
      -n|--dry-run)     dry_run=yes; shift 1 ;;
      -a|--add-new)     add_new=yes; shift 1 ;;
      -m|--mode)        mode=$2; shift 2;;
      --D2)             prefix=$2; shift 2 ;;
      -d|--D1|--folder) folder=$2; shift 2 ;;
      -t|--trim-cnt)    trim_cnt=$2; shift 2 ;;

      *) echo Impl.error; return 1 ;;
    esac
  done

  shift 1
  if [[ -n $prefix ]]; then
    if [[ -n $1 ]]; then
      echo Unexpected pos. arg.
      return $PRINT_ES;
    fi
  else
    if [[ -z $1 ]]; then
      echo Prefix not set
      return $PRINT_ES;
    else
      prefix=$1
    fi
  fi

  ! [[ -d $prefix ]] && { echo Prefix $prefix not found; return 1; }
  ! [[ -d ${folder:=.} ]] && { echo Folder $folder not found; return 1; }

  if [[ ${mode:=folder} != folder ]] && [[ $mode != git ]]; then
    echo Invalid mode: $mode
    return $PRINT_ES
  fi

  declare -a files
  if [[ $mode = folder ]]; then
    shopt -s globstar  # won't work for older Bash shells
    files=( "${folder%/}"/**/* )
  else
    git status &> /dev/null || { echo Not a git project.; return 1; }
    mapfile -t < <( git diff $staged --name-only "$folder" ) files
  fi

  if [[ -z $trim_cnt ]]; then
    local shards
    IFS='/' read -ra shards <<< "${folder#/}"
    trim_cnt=${#shards[@]}
  fi

  echo "$folder (project) .vs. $prefix (counterpart)"
  echo

  local file find_out desc
  declare -a exclude
  if [[ -n $add_new ]]; then
    for counter in "${prefix%/}"/**/*; do
      file=${folder%/}/${counter/$prefix/}
      if [[ -n ${exclude[*]} ]]; then
        [[ $file =~ ($(IFS=\|; echo "${exclude[*]}")) ]] && continue
      fi

      ## constructing `file` variable may leave double slash (//),
      ## which `find` command does not handle.
      find_out=$(find "$folder" -type f -wholename "${file/\/\//\/}")

      if [[ -z $find_out ]]; then
        [[ -d $counter ]] && continue
        [[ -n $dry_run ]] && { echo "NEW: ${counter}"; continue; }

        desc=
        echo "Not in project: $counter"
        desc+='[c] copy to project\t'
        desc+='[r] remove from counterpart\t'
        desc+='[e] exclude parent dir of the current file\n'
        desc+='Press the corresponding key to take an action.\n'
        desc+='Or any other key to continue.\n'
        echo -e $desc

        # read -srk1    # zsh syntaxis
        read -srn1    # bash syntaxis
        case $REPLY in
          c)
            mkdir -p "$(dirname "$file")"
            cp "$counter" "$file" && echo Copied!
            ;;
          r)
            # read -srk1 '?Confirm deletion - [yN] '    # zsh syntaxis
            read -srn1 -p 'Confirm deletion - [yN] '    # bash syntaxis
            [[ $REPLY =~ [yY] ]] && rm "$counter"
            echo
            ;;
          e)
            exclude+=( "$(dirname "$file")" )
            ;;
          *)
        esac
      fi
    done
  fi

  local counter
  for file in "${files[@]}"; do
    counter=$(sed -r "s;([^\/]+\/){$trim_cnt}(.*);\2;" <<< "$file")
    counter="${prefix%/}/$counter"

    [[ $mode = folder ]] && [[ -d $file || -d $counter ]] && continue

    ## Why check `file`? â”€ `git diff` reports also deleted.
    ! [[ -f $file ]] && { echo Not in project: $file; continue; }
    ! [[ -f $counter ]] && { echo Not in counterpart: $counter; continue; }

    if [[ -n $dry_run ]]; then
      echo $file -- $counter
      continue
    fi

    cmp -s $file $counter && continue
    vimdiff $file $counter
  done
}


difff "$@"
es=$?

case $es in
  "$PRINT_ES") echo; help_msg ;;
  *) exit $es ;;
esac
