#!/bin/bash

if [[ $EDITOR = nvim ]]; then
  vimdiff() { nvim -d "$@"; }
fi

NC='\033[0m'
BRED='\033[1;31m'
GREEN='\033[0;32m'
BGREEN='\033[1;32m'
PRINT_ES=21 # On which exit status to print help message
REGEX_PATTERN=false

help_msg() {
  printf 'Usage from anywhere:\n'
  printf '    diff [<options>] -D1 <project> -D2 <counter>\n'
  printf 'From a <project> directory:\n'
  printf '    difff [<options>] <prefix>\n'
  printf 'Here <prefix> is the path to a <counter> directory\n\n'

  printf 'Allowed <options>:\n'
  printf '%-40s %s\n' '-s|--staged' 'Use --staged flag in `git diff`.'
  printf '%-40s %s\n' '-n|--dry-run' 'Show how it would be w/o doing anything.'
  printf '%-40s %s\n' '-a|--add-new' 'Add new files from the counterpart directory.'
  printf '%-40s %s\n' '--regex' 'Use regex instead of shell pattern matching.'

  printf '%-40s %s\n' '-m|--mode=<mode>' '<mode> can be git or folder.'
  printf '%-40s %s\n' '-d|--folder=<dir>' 'Parent folder of the target directory limiting #files to be compared.'
  printf '%-40s %s\n' '-t|--trim-cnt=<N>' 'Trim <N> leading dirs from the target directory path.'
  printf '%-40s %s\n' '-i|--ignore=<folder/pattern>' 'Ignore directories or file patterns. The option can be repeated. '
  printf '%-40s %s\n' ' ' 'Leave trailing "/" to treat as a directory.'
}

function matches_path() {
  local target=$1
  shift

  if $REGEX_PATTERN; then
    for path in "$@"; do
      [[ -n "$path" ]] && [[ "$target" =~ $path ]] && return 0
    done
  else
    for path in "$@"; do
      case $target in
      $path) return 0 ;; # Do not use quotes around $path
      *) ;;
      esac
    done
  fi

  return 1
}

function difff() {
  local long_opts='D1:,D2:,ignore:,trim-cnt:,folder:,mode:,staged,dry-run,add-new,regex,help'
  local short_opts='i:t:,d:,m:,s,n,a,r,h'
  local params

  params=$(getopt -o $short_opts -l $long_opts --name "$0" -- "$@") ||
    {
      echo Aborting..
      return $PRINT_ES
    }
  eval set -- "$params"

  local folder prefix
  local staged dry_run add_new mode trim_cnt
  while [[ $1 != -- ]]; do
    case $1 in
      -h|--help)        help_msg; return ;;
      -s|--staged)      staged=--staged; shift ;;
      -n|--dry-run)     dry_run=yes; shift ;;
      -a|--add-new)     add_new=yes; shift ;;
      -m|--mode)        mode=$2; shift 2;;
      -i|--ignore)      ignore+=( "$2" ); shift 2 ;;
      -r|--regex)       REGEX_PATTERN=true; shift 1 ;;
      --D2)             prefix=$2; shift 2 ;;
      -d|--D1|--folder) folder=$2; shift 2 ;;
      -t|--trim-cnt)    trim_cnt=$2; shift 2 ;;

      *) echo Impl.error; return 1 ;;
    esac
  done

  shift
  if [[ -z $prefix ]]; then
    if [[ -z $1 ]]; then
      echo Prefix not set
      return $PRINT_ES
    else
      prefix=$1
      shift
    fi
  fi

  if [[ -n $1 ]]; then
    echo "Unexpected pos. arg: $1"
    return $PRINT_ES
  fi

  ! [[ -d $prefix ]] && {
    echo Prefix $prefix not found
    return 1
  }
  ! [[ -d ${folder:=.} ]] && {
    echo Folder $folder not found
    return 1
  }

  if [[ ${mode:=folder} != folder ]] && [[ $mode != git ]]; then
    echo Invalid mode: $mode
    return $PRINT_ES
  fi

  declare -a files
  if [[ $mode = folder ]]; then
    shopt -s globstar # won't work for older Bash shells
    files=("${folder%/}"/**/*)
  else
    git status &>/dev/null || {
      echo Not a git project.
      return 1
    }
    mapfile -t files < <(git diff $staged --name-only "$folder")
  fi

  if [[ -z $trim_cnt ]]; then
    local shards
    IFS='/' read -ra shards <<<"${folder#/}"
    trim_cnt=${#shards[@]}
  fi

  echo -ne "$folder ${BGREEN}(project)${NC}"
  echo -e " .vs. $prefix ${BRED}(counterpart)${NC}"
  echo

  local file find_out desc
  declare -a exclude
  if [[ -n $add_new ]]; then
    for counter in "${prefix%/}"/**/*; do
      matches_path "$counter" "${ignore[@]}" && continue

      file=${folder%/}/${counter/$prefix/}
      if [[ -n ${exclude[*]} ]]; then
        [[ $file =~ ($(
          IFS=\|
          echo "${exclude[*]}"
        )) ]] && continue
      fi

      ## constructing `file` variable may leave double slash (//),
      ## which `find` command does not handle.
      find_out=$(find "$folder" -type f -wholename "${file/\/\//\/}")

      if [[ -z $find_out ]]; then
        [[ -d $counter ]] && continue
        [[ -n $dry_run ]] && {
          echo "NEW: ${counter}"
          continue
        }

        desc=
        echo "Not in project: $counter"
        desc+='[c] copy to project\t'
        desc+='[r] remove from counterpart\t'
        desc+='[e] exclude parent dir of the current file\n'
        desc+='Press the corresponding key to take an action.\n'
        desc+='Or any other key to continue.\n'
        echo -e $desc

        # read -srk1    # zsh syntax
        read -srn1 # bash syntax
        case $REPLY in
        c)
          mkdir -p "$(dirname "$file")"
          cp "$counter" "$file" && echo -e "${GREEN}Copied!${NC}"
          ;;
        r)
          # read -srk1 '?Confirm deletion - [yN] '    # zsh syntaxis
          read -srn1 -p 'Confirm deletion - [yN] ' # bash syntaxis
          [[ $REPLY =~ [yY] ]] && rm "$counter"
          echo
          ;;
        e)
          exclude+=("$(dirname "$file")")
          ;;
        *) ;;
        esac
      fi
    done
  fi

  local counter
  for file in "${files[@]}"; do
    matches_path "$counter" "${ignore[@]}" && continue
    counter=$(sed -r "s;\/?([^\/]+\/){$trim_cnt}(.*);\2;" <<<"$file")
    counter="${prefix%/}/$counter"

    [[ $mode = folder ]] && [[ -d $file || -d $counter ]] && continue

    ## Why check `file`? â”€ `git diff` reports also deleted.
    ! [[ -f $file ]] && {
      echo Not in project: $counter
      continue
    }
    ! [[ -f $counter ]] && {
      echo Not in counterpart: $file
      continue
    }

    if [[ -n $dry_run ]]; then
      echo $file -- $counter
      continue
    fi

    cmp -s $file $counter && continue
    vimdiff $file $counter
    sleep 0.28 # small window to abort with <Ctrl-c>
    ## 250ms - is the avg reaction time
  done
}

difff "$@"
es=$?

case $es in
"$PRINT_ES")
  echo
  help_msg
  ;;
*) exit $es ;;
esac
